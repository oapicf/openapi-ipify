//> using scala "3.3.1"
//> using lib "com.lihaoyi::cask:0.8.3"
//> using lib "com.lihaoyi::scalatags:0.12.0"
/**
 * openapi-ipify
 * OpenAPI client for ipify, a simple public IP address API
 *
 * OpenAPI spec version: 5.3.1-pre.0
 *
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator.
 *
 * https://openapi-generator.tech
 */


// generated from apiService.mustache
package org.openapitools.server.api

import _root_.org.openapitools.server.model.GetIp200Response
import scala.util.Failure
import scala.util.Try
import _root_.org.openapitools.server.model.*

/**
 * The DefaultService companion object.
 *
 * Use the DefaultService() companion object to create an instance which returns a 'not implemented' error
 * for each operation.
 *
 */
object DefaultService {

  /**
   * The 'Handler' is an implementation of DefaultService convenient for delegating or overriding individual functions
   */
  case class Handler[F[_]](
        getIpHandler : (format : Option[String], callback : Option[String]) => F[String]
  ) extends DefaultService[F] {

        override def getIp(format : Option[String], callback : Option[String]) : F[String] = {
          getIpHandler(format, callback)
        }
  }

  def apply() : DefaultService[Try] = DefaultService.Handler[Try](
        (_, _) => notImplemented("getIp")
  )

  private def notImplemented(name : String) = Failure(new Exception(s"TODO: $name not implemented"))
}

/**
 * The Default business-logic
 *
 *
 * The 'asHandler' will return an implementation which allows for easily overriding individual operations.
 *
 * equally there are "on&lt;Function&gt;" helper methods for easily overriding individual functions
 *
 * @tparam F the effect type (Future, Try, IO, ID, etc) of the operations
 */
trait DefaultService[F[_]] {
  /** Get your public IP address
   * 
   * @return String
   */
  def getIp(format : Option[String], callback : Option[String]) : F[String]

  /**
   * override getIp with the given handler
   * @return a new implementation of DefaultService[F] with getIp overridden using the given handler
   */
  final def onGetIp(handler : (format : Option[String], callback : Option[String]) => F[String]) : DefaultService[F] = {
    asHandler.copy(getIpHandler = handler)
  }

  /**
   * @return a Handler implementation of this service
   */
  final def asHandler : DefaultService.Handler[F] = this match {
      case h : DefaultService.Handler[F] => h
      case _ =>
        DefaultService.Handler[F](
              (format, callback) => getIp(format, callback)
        )
  }

  /**
   * This function will change the effect type of this service.
   *
   * It's not unlike a typical map operation from A => B, except we're not mapping
   * a type from A to B, but rather from F[A] => G[A] using the 'changeEffect' function.
   *
   * For, this could turn an asynchronous service (one which returns Future[_] types) into
   * a synchronous one (one which returns Try[_] types) by awaiting on the Future.
   *
   * It could change an IO type (like cats effect or ZIO) into an ID[A] which is just:
   * ```
   * type ID[A] => A
   * ```
   *
   * @tparam G the new "polymorphic" effect type
   * @param changeEffect the "natural transformation" which can change one effect type into another
   * @return a new DefaultService service implementation with effect type [G]
   */
  final def mapEffect[G[_]](changeEffect : [A] => F[A] => G[A]) : DefaultService[G] = {
    val self = this

    new DefaultService[G] {
        override def getIp(format : Option[String], callback : Option[String]) : G[String] = changeEffect {
          self.getIp(format, callback)
        }
    }
  }
}
